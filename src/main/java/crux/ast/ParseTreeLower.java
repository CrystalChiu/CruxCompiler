package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;

import javax.swing.plaf.nimbus.State;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   *
   * @return a {@link DeclList} object representing the top-level AST.
   */

  public DeclarationList lower(CruxParser.ProgramContext program) {
    symTab.enter();
    List<Declaration> declarations = new ArrayList<>();

    for (CruxParser.DeclContext declContext : program.declList().decl()) {
      Declaration declaration = declVisitor.visit(declContext);
      declarations.add(declaration);
    }

    Position position = new Position(program.start.getLine());

    return new DeclarationList(position, declarations);
  }

  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StmtList} AST object.
   */
  // TODO
  private StatementList lower(CruxParser.StmtListContext stmtList) {
    List<Statement> statements = new ArrayList<>();

    for (CruxParser.StmtContext stmtContext : stmtList.stmt()) {
      Statement astStmt = stmtVisitor.visit(stmtContext);
      statements.add(astStmt);
    }

    int lineNum = stmtList.start.getLine();
    Position position = new Position(lineNum);

    return new StatementList(position, statements);
  }

  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   *
   * @return a {@link StmtList} AST object.
   */
  private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
    symTab.enter();

    List<Statement> statements = new ArrayList<>();
    if (stmtBlock.stmtList() != null) {
      CruxParser.StmtListContext stmtListContext = stmtBlock.stmtList();

      for (CruxParser.StmtContext stmtContext : stmtListContext.stmt()) {
        Statement astStmt = stmtVisitor.visit(stmtContext);
        statements.add(astStmt);
      }
    }

    int lineNumber = stmtBlock.start.getLine();
    Position position = new Position(lineNumber);

    symTab.exit();

    return new StatementList(position, statements);
  }

  /**
   Helper function
   **/
  public Type toType(CruxParser.TypeContext ctx) {
    String typeText = ctx.getText().toLowerCase();

    switch (typeText) {
      case "int":
        return new IntType();
      case "bool":
        return new BoolType();
      case "void":
        return new VoidType();
      default:
        throw new IllegalArgumentException("Invalid type: " + typeText);
    }
  }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {

    /**
     * Visit a parse tree var decl and create an AST {@link VarariableDeclaration}
     *
     * @return an AST {@link VariableDeclaration}
     */
     @Override
     public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
       int lineNum = ctx.start.getLine();
       String varName = ctx.IDENTIFIER().getText();
       Position position = new Position(lineNum);
       Type varType = toType(ctx.type());

       // add to symbol table
       Symbol symbol = symTab.add(position, varName, varType);

       return new VariableDeclaration(position, symbol);
     }

    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDeclaration}
     *
     * @return an AST {@link ArrayDeclaration}
     */
      @Override
      public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {
        int lineNum = ctx.start.getLine();
        int arrSize = Integer.parseInt(ctx.INTEGER().getText());
        String arrName = ctx.IDENTIFIER().getText();
        Position position = new Position(lineNum);
        Type arrType = toType(ctx.type());

        // add to symbol table
        Type arrSymbolType = new ArrayType(arrSize, arrType);
        Symbol symbol = symTab.add(position, arrName, arrSymbolType);

        return new ArrayDeclaration(position, symbol);
      }

    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     *
     * @return an AST {@link FunctionDefinition}
     */
    @Override
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      String funcName = ctx.IDENTIFIER().getText();
      int lineNumber = ctx.start.getLine();
      Position position = new Position(lineNumber);
      Type returnType = toType(ctx.type());

      symTab.enter();

      List<Type> parameterTypes = new ArrayList<>();
      List<Symbol> parameterSymbols = new ArrayList<>();

      if (ctx.paramList() != null) {
        for (CruxParser.ParamContext paramCtx : ctx.paramList().param()) {
          String paramName = paramCtx.IDENTIFIER().getText();
          Type paramType = toType(paramCtx.type());
          Symbol paramSymbol = symTab.add(position, paramName, paramType);
          parameterSymbols.add(paramSymbol);
          parameterTypes.add(paramType);
        }
      }

      FuncType functionType = new FuncType(TypeList.of(parameterTypes.toArray(new Type[0])), returnType);
      Symbol funcSymbol = symTab.add(position, funcName, functionType);

      symTab.enter();

      StatementList functionBody = lower(ctx.stmtBlock());

      symTab.exit();

      return new FunctionDefinition(position, funcSymbol, parameterSymbols, functionBody);
    }
  }

    /**
   * A parse tree visitor to create AST nodes derived from {@link Stmt}
   */
  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we
     * implement earlier.
     *
     * @return an AST {@link VariableDeclaration}
     */

     @Override
     public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
       String varName = ctx.IDENTIFIER().getText();
       int lineNumber = ctx.start.getLine();
       Position position = new Position(lineNumber);
       Type varType = toType(ctx.type());

       // add to symbol table
       Symbol symbol = symTab.add(position, varName, varType);

       return new VariableDeclaration(position, symbol);
     }

    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
     @Override
     public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
       int lineNumber = ctx.start.getLine();
       Position position = new Position(lineNumber);

       // visit lhs
       Expression location = exprVisitor.visit(ctx.designator());
       // visit rhs
       Expression value = exprVisitor.visit(ctx.expr0());

       return new Assignment(position, location, value);
     }

    /**
     * Visit a parse tree assignment nosemi stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
     @Override
     public Statement visitAssignStmtNoSemi(CruxParser.AssignStmtNoSemiContext ctx) {
       Expression location = exprVisitor.visit(ctx.designator());
       Expression value = exprVisitor.visit(ctx.expr0());
       Position position = makePosition(ctx);

       return new Assignment(position, location, value);
     }

    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statementt}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement later.
     *
     * @return an AST {@link Call}
     */
     @Override
     public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
       CruxParser.CallExprContext callExprCtx = ctx.callExpr();

       String funcName = callExprCtx.IDENTIFIER().getText();
       int lineNumber = callExprCtx.start.getLine();
       Position position = new Position(lineNumber);

       Symbol functionSymbol = symTab.lookup(position, funcName);

       List<Expression> args = new ArrayList<>();
       if (callExprCtx.exprList() != null) {
         for (CruxParser.Expr0Context expr : callExprCtx.exprList().expr0()) {
           Expression arg = exprVisitor.visit(expr);
           args.add(arg);
         }
       }

       return new Call(position, functionSymbol, args);
     }

    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */

      @Override
      public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
        Expression cond = exprVisitor.visit(ctx.expr0());
        StatementList thenBlock = lower(ctx.stmtBlock(0));
        Position position = makePosition(ctx);

        StatementList elseBlock = new StatementList(position, new ArrayList<>());
        if (ctx.stmtBlock().size() > 1) {
          elseBlock = lower(ctx.stmtBlock(1));
        }

        return new IfElseBranch(position, cond, thenBlock, elseBlock);
      }

    /**
     * Visit a parse tree for loop and create an AST {@link Loop}. You'll going to use a similar
     * techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this construction.
     *
     * @return an AST {@link Loop}
     */
     @Override
     public Statement visitLoopStmt(CruxParser.LoopStmtContext ctx) {
       StatementList loopBody = lower(ctx.stmtBlock());
       Position position = makePosition(ctx);

       return new Loop(position, loopBody);
     }

    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */
    @Override
    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {

      Expression returnVal = null;
      if (ctx.expr0() != null) {
        returnVal = exprVisitor.visit(ctx.expr0());
      }

      Position position = makePosition(ctx);

      return new Return(position, returnVal);
    }

    /**
     * Creates a Break node
     */
    @Override
    public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
      return new Break(makePosition(ctx));
    }

    /**
     * Creates a Continue node
     */
    @Override
    public Statement visitContinueStmt(CruxParser.ContinueStmtContext ctx) {
      return new Continue(makePosition(ctx));
    }
  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     *  Helper Function, for Expr0
     */
    private OpExpr.Operation toOp0(String symbol) {
      switch (symbol) {
        case ">=":
          return OpExpr.Operation.GE;
        case "<=":
          return OpExpr.Operation.LE;
        case "!=":
          return OpExpr.Operation.NE;
        case "==":
          return OpExpr.Operation.EQ;
        case ">":
          return OpExpr.Operation.GT;
        case "<":
          return OpExpr.Operation.LT;
        case "+":
          return OpExpr.Operation.ADD;
        case "-":
          return OpExpr.Operation.SUB;
        case "*":
          return OpExpr.Operation.MULT;
        case "/":
          return OpExpr.Operation.DIV;
        default:
          throw new IllegalArgumentException("Invalid operator: " + symbol);
      }
    }

    /**
     *  Helper Function, for Expr1
     */
    private OpExpr.Operation toOp1(String operatorSymbol) {
      switch (operatorSymbol) {
        case "+":
          return OpExpr.Operation.ADD;
        case "-":
          return OpExpr.Operation.SUB;
        case "||":
          return Operation.LOGIC_OR;
        default:
          throw new IllegalArgumentException("Invalid operator: " + operatorSymbol);
      }
    }

    /**
     * Helper Function for Expr2
     */
    private OpExpr.Operation toOp2(String operatorSymbol) {
      switch (operatorSymbol) {
        case "*":
          return OpExpr.Operation.MULT;
        case "/":
          return OpExpr.Operation.DIV;
        case "&&":
          return Operation.LOGIC_AND;
        default:
          throw new IllegalArgumentException("Invalid operator: " + operatorSymbol);
      }
    }

    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      if (ctx.op0() == null) {
        return visit(ctx.expr1(0));
      }

      Expression lhs = ctx.expr1(0).accept(exprVisitor);

      if(ctx.op0() == null) {
        return lhs;
      }

      String opSymbol = ctx.op0().getText();
      OpExpr.Operation op = toOp0(opSymbol);

      Expression rhs = ctx.expr1(1).accept(exprVisitor);

      Position position = makePosition(ctx);

      return new OpExpr(position, op, lhs, rhs);
    }

    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      if (ctx.op1() == null) {
        return visit(ctx.expr2());
      }

      String opSymbol = ctx.op1().getText();
      OpExpr.Operation op = toOp1(opSymbol);

      Expression lhs = visit(ctx.expr1());
      Expression rhs = visit(ctx.expr2());

      Position position = makePosition(ctx);

      return new OpExpr(position, op, lhs, rhs);
    }

    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      if (ctx.op2() == null) {
        return visit(ctx.expr3());
      }

      String operatorSymbol = ctx.op2().getText();
      OpExpr.Operation op = toOp2(operatorSymbol);

      Expression lhs = visit(ctx.expr2());
      Expression rhs = visit(ctx.expr3());

      Position position = makePosition(ctx);

      return new OpExpr(position, op, lhs, rhs);
    }

    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
      Position position = new Position(ctx.start.getLine());

      if (ctx.NOT() != null) {
        Expression operand = visit(ctx.expr3());
        return new OpExpr(position, OpExpr.Operation.LOGIC_NOT, operand, null);
      }

      if (ctx.OPEN_PAREN() != null) {
        return visit(ctx.expr0());
      }

      if (ctx.designator() != null) {
        return visit(ctx.designator());
      }

      if (ctx.callExpr() != null) {
        return visit(ctx.callExpr());
      }

      if (ctx.literal() != null) {
        return visit(ctx.literal());
      }

      throw new IllegalArgumentException("Unsupported expression in Expr3");
    }

    /**
     * Create an Call Node
     */
    @Override
    public Call visitCallExpr(CruxParser.CallExprContext ctx) {
      String functionName = ctx.IDENTIFIER().getText();
      Position position = makePosition(ctx);
      Symbol functionSymbol = symTab.lookup(position, functionName);

      List<Expression> arguments = new ArrayList<>();
      if (ctx.exprList() != null) {
        for (CruxParser.Expr0Context exprCtx : ctx.exprList().expr0()) {
          Expression argument = exprVisitor.visit(exprCtx);
          arguments.add(argument);
        }
      }

      return  new Call(position, functionSymbol, arguments);
    }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
      Position position = new Position(ctx.start.getLine());
      Symbol symbol = symTab.lookup(position, ctx.IDENTIFIER().getText());

      if (ctx.OPEN_BRACKET() != null) {
        Expression index = visit(ctx.expr0());
        return new ArrayAccess(position, symbol, index);
      }
      return new VarAccess(position, symbol);
    }

    /**
     * Create an Literal Node
     */
    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      Position position = new Position(ctx.start.getLine());

      //create node based on literal type
      if (ctx.INTEGER() != null) {
        int intValue = Integer.parseInt(ctx.INTEGER().getText());
        return new LiteralInt(position, intValue);
      } else if (ctx.TRUE() != null) {
        return new LiteralBool(position, true);
      } else if (ctx.FALSE() != null) {
        return new LiteralBool(position, false);
      }

      throw new IllegalArgumentException("Unknown literal type in LiteralContext");
    }
  }
}
